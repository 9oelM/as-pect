var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
define("util/ILogTarget", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("util/LogValue", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A virtual representation of a discrete value logged to from AssemblyScript.
     */
    var LogValue = /** @class */ (function () {
        function LogValue() {
            /**
             * If a pointer is referenced, this is the precise memory location of the referenced block of
             * data.
             */
            this.pointer = 0;
            /**
             * If a pointer is referenced and isn't a string, this is the size of the referenced block of
             * data.
             */
            this.offset = 0;
            /**
             * If a pointer is referenced and ins't a string, this is an array of bytes to be logged byt the
             * logger.
             */
            this.bytes = [];
            /**
             * This is a message generated by the TestSuite to be displayed in the logger.
             */
            this.message = "";
            /**
             * This is the relevant stack trace, filtered with the `/wasm/i` regex.
             */
            this.stack = "";
            /**
             * This is the referenced log target.
             */
            this.target = null;
        }
        return LogValue;
    }());
    exports.LogValue = LogValue;
});
define("util/ActualValue", ["require", "exports", "util/LogValue"], function (require, exports, LogValue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A class representing a reported expected or actual value. It shares a lot of properties with
     * LogValue, so those are copied over.
     */
    var ActualValue = /** @class */ (function (_super) {
        __extends(ActualValue, _super);
        function ActualValue() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * An indicator if the actual expected value is negated.
             */
            _this.negated = false;
            return _this;
        }
        return ActualValue;
    }(LogValue_1.LogValue));
    exports.ActualValue = ActualValue;
});
define("test/TestResult", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TestResult = /** @class */ (function () {
        function TestResult() {
            /**
             * The actual test's name or description.
             */
            this.testName = "";
            /**
             * The indicator to see if the test passed.
             */
            this.pass = false;
            /**
             * The time in milliseconds indicating how long the test ran.
             */
            this.time = 0;
            /**
             * The reported actual value description.
             */
            this.actual = null;
            /**
             * The reported expected value description.
             */
            this.expected = null;
            /**
             * If the test failed, this is the message describing why the test failed.
             */
            this.message = "";
            /**
             * A set of strings logged by the test itself.
             */
            this.logs = [];
            /**
             * The generated stack trace if the test errored.
             */
            this.stack = null;
            /**
             * This value is set to true if the test is expected to throw.
             */
            this.negated = false;
        }
        return TestResult;
    }());
    exports.TestResult = TestResult;
});
define("test/TestGroup", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TestGroup = /** @class */ (function () {
        function TestGroup() {
            this.describePointers = [];
            // callback properties
            this.beforeEachPointers = [];
            this.afterEachPointers = [];
            this.beforeAllPointers = [];
            this.afterAllPointers = [];
            // test properties
            this.testFunctionPointers = [];
            this.testNamePointers = [];
            this.testMessagePointers = [];
            this.testThrows = [];
            // tests and todos
            this.tests = [];
            this.todos = [];
            // logs
            this.logs = [];
            this.name = "";
            this.pass = true;
            this.reason = "";
            this.time = 0;
        }
        TestGroup.prototype.fork = function () {
            var forked = new TestGroup();
            forked.describePointers = this.describePointers.slice();
            forked.beforeEachPointers = this.beforeEachPointers.slice();
            forked.afterEachPointers = this.afterEachPointers.slice();
            forked.beforeAllPointers = this.beforeAllPointers.slice();
            forked.afterAllPointers = this.afterAllPointers.slice();
            return forked;
        };
        return TestGroup;
    }());
    exports.TestGroup = TestGroup;
});
define("test/TestReporter", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TestReporter = /** @class */ (function () {
        function TestReporter() {
        }
        return TestReporter;
    }());
    exports.TestReporter = TestReporter;
});
define("reporter/DefaultTestReporter", ["require", "exports", "chalk", "test/TestReporter"], function (require, exports, chalk_1, TestReporter_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    chalk_1 = __importDefault(chalk_1);
    function stringifyActualValue(type, value) {
        if (!value)
            return "";
        var byteString = "";
        if (value.bytes.length > 0) {
            byteString = "\n               " + createReferenceString(value.bytes, value.pointer, value.offset)
                .split("\n")
                .join("\n               ");
        }
        var stackString = "\n           " + value.stack
            .split("\n")
            .join("\n           ");
        return type === 1 /* Expected */
            ? chalk_1.default(templateObject_1 || (templateObject_1 = __makeTemplateObject(["{green ", "}{blue ", "}{yellow ", "}\n"], ["{green ", "}{blue ", "}{yellow ", "}\\n"])), value.message, byteString, stackString) : chalk_1.default(templateObject_2 || (templateObject_2 = __makeTemplateObject(["{red ", "}{blue ", "}{yellow ", "}\n"], ["{red ", "}{blue ", "}{yellow ", "}\\n"])), value.message, byteString, stackString);
    }
    /**
     * This function generates a 2 digit hexadecimal string from the given number.
     *
     * @param {number} value - A number from [0-255].
     * @returns {string} - The hexadecimal string representing the byte
     */
    function hex(value) {
        var result = value.toString(16);
        if (result.length === 1)
            return "0" + result;
        return result;
    }
    /**
     * This function returns a string that formats the bytes into rows of 8 bytes with a space between
     * byte 4 and 5 on each row.
     *
     * @param {number[]} bytes - The byte array
     * @param {number} pointer - The pointer of the reference.
     * @param {number} offset - The offset of the reference.
     */
    function createReferenceString(bytes, pointer, offset) {
        var referenceEnd = pointer + offset;
        // start with a tabbed out string
        var result = "Range: [dec: " + pointer.toString() + "~" + referenceEnd.toString() + "] [hex: 0x" + pointer.toString(16) + "~0x" + referenceEnd.toString(16) + "]";
        result += "\n07 06 05 04   03 02 01 00";
        result += "\n~~~~~~~~~~~~~~~~~~~~~~~~~";
        result += "\n";
        // for each byte
        for (var i = 0; i < offset; i++) {
            // append a byte and an empty space
            result += hex(bytes[i]) + " ";
            if (i % 8 === 7) {
                // every 8 characters add a newline
                result += "\n";
            }
            else if (i % 4 === 3) {
                // every 4 characters add an extra two spaces
                result += "  ";
            }
        }
        // remove leading space
        return result.trimRight();
    }
    var DefaultTestReporter = /** @class */ (function (_super) {
        __extends(DefaultTestReporter, _super);
        function DefaultTestReporter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultTestReporter.prototype.onStart = function (_suite) {
        };
        DefaultTestReporter.prototype.onGroupStart = function (group) {
            console.log("");
            console.log(chalk_1.default(templateObject_3 || (templateObject_3 = __makeTemplateObject(["[Describe]: ", ""], ["[Describe]: ", ""])), group.name));
            console.log("");
        };
        DefaultTestReporter.prototype.onGroupFinish = function (group) {
            var result = group.pass
                ? chalk_1.default(templateObject_4 || (templateObject_4 = __makeTemplateObject(["{green \u2714 PASS}"], ["{green \u2714 PASS}"]))) : chalk_1.default(templateObject_5 || (templateObject_5 = __makeTemplateObject(["{red \u2716 FAIL}"], ["{red \u2716 FAIL}"])));
            var todoCount = group.todos.length;
            var successCount = group.tests.filter(function (e) { return e.pass; }).length;
            var count = group.tests.length;
            for (var _i = 0, _a = group.logs; _i < _a.length; _i++) {
                var logValue = _a[_i];
                this.onLog(logValue);
            }
            console.log("");
            console.log(chalk_1.default(templateObject_6 || (templateObject_6 = __makeTemplateObject(["  [Result]: ", ""], ["  [Result]: ", ""])), result));
            console.log(chalk_1.default(templateObject_7 || (templateObject_7 = __makeTemplateObject(["   [Tests]: ", " pass, ", " fail, ", " total"], ["   [Tests]: ", " pass, ", " fail, ", " total"])), successCount.toString(), (count - successCount).toString(), count.toString()));
            console.log(chalk_1.default(templateObject_8 || (templateObject_8 = __makeTemplateObject(["    [Todo]: ", " tests"], ["    [Todo]: ", " tests"])), todoCount.toString()));
            console.log(chalk_1.default(templateObject_9 || (templateObject_9 = __makeTemplateObject(["    [Time]: ", "ms"], ["    [Time]: ", "ms"])), group.time.toString()));
        };
        DefaultTestReporter.prototype.onTestStart = function (_group, _test) { };
        DefaultTestReporter.prototype.onTestFinish = function (_group, test) {
            if (test.pass) {
                console.log(chalk_1.default(templateObject_10 || (templateObject_10 = __makeTemplateObject([" {green [Success]: \u2714} ", ""], [" {green [Success]: \u2714} ", ""])), test.testName));
            }
            else {
                console.log(chalk_1.default(templateObject_11 || (templateObject_11 = __makeTemplateObject(["    {red [Fail]: \u2716} ", ""], ["    {red [Fail]: \u2716} ", ""])), test.testName));
                console.log("");
                if (!test.negated) {
                    console.log("   [Actual]: " + stringifyActualValue(0 /* Actual */, test.actual));
                    console.log(" [Expected]: " + stringifyActualValue(1 /* Expected */, test.expected));
                }
                if (test.message) {
                    console.log(chalk_1.default(templateObject_12 || (templateObject_12 = __makeTemplateObject(["  [Message]: {yellow ", "}"], ["  [Message]: {yellow ", "}"])), test.message));
                }
                if (test.stack) {
                    console.log("    [Stack]: " + test.stack.split("\n").join("\n           "));
                }
            }
            for (var _i = 0, _a = test.logs; _i < _a.length; _i++) {
                var logValue = _a[_i];
                this.onLog(logValue);
            }
        };
        DefaultTestReporter.prototype.onFinish = function (suite) {
            var result = suite.pass
                ? chalk_1.default(templateObject_13 || (templateObject_13 = __makeTemplateObject(["{green \u2714 Pass}"], ["{green \u2714 Pass}"]))) : chalk_1.default(templateObject_14 || (templateObject_14 = __makeTemplateObject(["{red \u2716 Fail}"], ["{red \u2716 Fail}"])));
            var count = suite.testGroups
                .map(function (e) { return e.tests.length; })
                .reduce(function (a, b) { return a + b; });
            var successCount = suite.testGroups
                .map(function (e) { return e.tests.filter(function (f) { return f.pass; }).length; })
                .reduce(function (a, b) { return a + b; });
            console.log("");
            console.log("~".repeat(process.stdout.columns - 10));
            console.log("");
            console.log(chalk_1.default(templateObject_15 || (templateObject_15 = __makeTemplateObject(["    [File]: ", ""], ["    [File]: ", ""])), suite.file));
            console.log(chalk_1.default(templateObject_16 || (templateObject_16 = __makeTemplateObject(["  [Groups]: ", " pass, ", " total"], ["  [Groups]: ", " pass, ", " total"])), suite.testGroups.filter(function (e) { return e.pass; }).length.toString(), suite.testGroups.length.toString()));
            console.log(chalk_1.default(templateObject_17 || (templateObject_17 = __makeTemplateObject(["  [Result]: ", ""], ["  [Result]: ", ""])), result));
            console.log(chalk_1.default(templateObject_18 || (templateObject_18 = __makeTemplateObject([" [Summary]: ", " pass, ", " fail, ", " total"], [" [Summary]: ", " pass, ", " fail, ", " total"])), successCount.toString(), (count - successCount).toString(), count.toString()));
            console.log(chalk_1.default(templateObject_19 || (templateObject_19 = __makeTemplateObject(["    [Time]: ", "ms"], ["    [Time]: ", "ms"])), suite.time.toString()));
            console.log("");
        };
        DefaultTestReporter.prototype.onTodo = function (_group, todo) {
            console.log(chalk_1.default(templateObject_20 || (templateObject_20 = __makeTemplateObject(["    {yellow [Todo]:} ", ""], ["    {yellow [Todo]:} ", ""])), todo));
        };
        DefaultTestReporter.prototype.onLog = function (logValue) {
            // create string representations of the pointer
            var pointer = logValue.pointer.toString();
            var hexPointer = logValue.pointer.toString(16);
            // log the log message
            if (logValue.pointer > 0) {
                console.log(chalk_1.default(templateObject_21 || (templateObject_21 = __makeTemplateObject(["     {yellow [Log]:} Reference at address [", "] [hex: 0x", "] ", ""], ["     {yellow [Log]:} Reference at address [", "] [hex: 0x", "] ", ""])), pointer, hexPointer, logValue.message));
            }
            else {
                console.log(chalk_1.default(templateObject_22 || (templateObject_22 = __makeTemplateObject(["     {yellow [Log]:} ", ""], ["     {yellow [Log]:} ", ""])), logValue.message));
            }
            // if there are bytes to show, create a logging representation of the bytes
            if (logValue.bytes.length > 0) {
                var value = createReferenceString(logValue.bytes, logValue.pointer, logValue.offset);
                console.log(chalk_1.default(templateObject_23 || (templateObject_23 = __makeTemplateObject(["            {blueBright ", "}"], ["            {blueBright ", "}"])), value.split("\n").join("\n            ")));
            }
            console.log(chalk_1.default(templateObject_24 || (templateObject_24 = __makeTemplateObject(["        {yellow ", "}\n"], ["        {yellow ", "}\\n"])), logValue.stack.split("\n").join("\n        ")));
        };
        return DefaultTestReporter;
    }(TestReporter_1.TestReporter));
    exports.DefaultTestReporter = DefaultTestReporter;
    var templateObject_1, templateObject_2, templateObject_3, templateObject_4, templateObject_5, templateObject_6, templateObject_7, templateObject_8, templateObject_9, templateObject_10, templateObject_11, templateObject_12, templateObject_13, templateObject_14, templateObject_15, templateObject_16, templateObject_17, templateObject_18, templateObject_19, templateObject_20, templateObject_21, templateObject_22, templateObject_23, templateObject_24;
});
define("util/timeDifference", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timeDifference = function (end, start) { return Math.round((end - start) * 1000) / 1000; };
});
define("test/TestContext", ["require", "exports", "test/TestGroup", "util/LogValue", "util/ActualValue", "test/TestResult", "reporter/DefaultTestReporter", "perf_hooks", "util/timeDifference"], function (require, exports, TestGroup_1, LogValue_2, ActualValue_1, TestResult_1, DefaultTestReporter_1, perf_hooks_1, timeDifference_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var wasmFilter = function (input) { return /wasm/i.test(input); };
    var TestContext = /** @class */ (function () {
        function TestContext() {
            this.file = "";
            this.groupStack = [new TestGroup_1.TestGroup()];
            this.testGroups = [];
            this.logTarget = this.groupStack[0];
            this.wasm = null;
            // test state machine values
            this.stack = "";
            this.message = "";
            this.actual = null;
            this.expected = null;
            this.time = 0;
            this.pass = true;
        }
        /**
         * Run the tests on the wasm module.
         */
        TestContext.prototype.run = function (wasm, reporter, file) {
            if (reporter === void 0) { reporter = new DefaultTestReporter_1.DefaultTestReporter(); }
            if (file === void 0) { file = ""; }
            this.wasm = wasm;
            this.file = file;
            var start = 0;
            var end = 0;
            var groupstart = 0;
            var groupend = 0;
            var teststart = 0;
            var testend = 0;
            var passed = true;
            // start the test suite
            reporter.onStart(this);
            start = perf_hooks_1.performance.now();
            testgroup: for (var _i = 0, _a = this.testGroups; _i < _a.length; _i++) {
                var group = _a[_i];
                // get the group's name
                var groupName = group.describePointers
                    .map(function (pointer) { return wasm.getString(pointer); })
                    .join(" ");
                group.name = groupName;
                // report the group as started
                reporter.onGroupStart(group);
                for (var _b = 0, _c = group.todos; _b < _c.length; _b++) {
                    var todo = _c[_b];
                    reporter.onTodo(group, wasm.getString(todo));
                }
                groupstart = perf_hooks_1.performance.now();
                // set the log target
                this.logTarget = group;
                // for each beforeAllCallback
                for (var _d = 0, _e = group.beforeAllPointers; _d < _e.length; _d++) {
                    var beforeAllCallback = _e[_d];
                    // call each beforeAll callback
                    var beforeAllResult = this.tryCall(beforeAllCallback);
                    // if the test fails
                    if (beforeAllResult === 0) {
                        groupend = perf_hooks_1.performance.now();
                        group.pass = false;
                        group.reason = "Test suite " + groupName + " failed in beforeAll callback.";
                        passed = false;
                        group.time = timeDifference_1.timeDifference(groupend, groupstart);
                        continue testgroup;
                    }
                }
                test: for (var i = 0; i < group.testFunctionPointers.length; i++) {
                    var testFunctionCallback = group.testFunctionPointers[i];
                    // create the test result
                    var result = new TestResult_1.TestResult();
                    group.tests.push(result);
                    this.logTarget = result;
                    result.testName = wasm.getString(group.testNamePointers[i]);
                    reporter.onTestStart(group, result);
                    teststart = perf_hooks_1.performance.now();
                    // for each beforeEach callback function pointer
                    for (var _f = 0, _g = group.beforeEachPointers; _f < _g.length; _f++) {
                        var beforeEachCallback = _g[_f];
                        var beforeEachResult = this.tryCall(beforeEachCallback);
                        // if beforeEach fails
                        if (beforeEachResult === 0) {
                            testend = perf_hooks_1.performance.now();
                            groupend = perf_hooks_1.performance.now();
                            group.pass = false;
                            group.reason = group.reason = "Test suite " + groupName + " failed in beforeEach callback.";
                            result.pass = false;
                            group.time = timeDifference_1.timeDifference(groupend, groupstart);
                            result.time = timeDifference_1.timeDifference(testend, teststart);
                            reporter.onTestFinish(group, result);
                            reporter.onGroupFinish(group);
                            continue testgroup;
                        }
                    }
                    var testCallResult = this.tryCall(testFunctionCallback);
                    var throws = group.testThrows[i];
                    testend = perf_hooks_1.performance.now();
                    result.time = timeDifference_1.timeDifference(testend, teststart);
                    result.pass = throws
                        ? (testCallResult === 0)
                        : (testCallResult === 1);
                    result.negated = throws;
                    if (!result.pass) {
                        // if it throws...
                        if (throws) {
                            // only set the message
                            result.message = this.wasm.getString(group.testMessagePointers[i]);
                        }
                        else {
                            // set the message, the actual, expected, and stack values
                            result.message = this.message;
                            result.actual = this.actual;
                            result.expected = this.expected;
                            result.stack = this.stack;
                        }
                    }
                    // for each afterEach callback function pointer
                    for (var _h = 0, _j = group.afterEachPointers; _h < _j.length; _h++) {
                        var afterEachCallback = _j[_h];
                        var afterEachResult = this.tryCall(afterEachCallback);
                        // if afterEach fails
                        if (afterEachResult === 0) {
                            testend = perf_hooks_1.performance.now();
                            groupend = perf_hooks_1.performance.now();
                            group.pass = false;
                            group.reason = group.reason = "Test suite " + groupName + " failed in afterEach callback.";
                            result.pass = false;
                            group.time = timeDifference_1.timeDifference(groupend, groupstart);
                            result.time = timeDifference_1.timeDifference(testend, teststart);
                            reporter.onTestFinish(group, result);
                            reporter.onGroupFinish(group);
                            continue testgroup;
                        }
                    }
                    reporter.onTestFinish(group, result);
                    this.logTarget = group;
                }
                // for each afterAllCallback
                for (var _k = 0, _l = group.afterAllPointers; _k < _l.length; _k++) {
                    var afterAllCallback = _l[_k];
                    // call each afterAll callback
                    var afterAllResult = this.tryCall(afterAllCallback);
                    // if the test fails
                    if (afterAllResult === 0) {
                        groupend = perf_hooks_1.performance.now();
                        group.pass = false;
                        group.reason = "Test suite " + groupName + " failed in beforeAll callback.";
                        passed = false;
                        group.time = timeDifference_1.timeDifference(groupend, groupstart);
                        reporter.onGroupFinish(group);
                        continue testgroup;
                    }
                }
                // finish the group
                groupend = perf_hooks_1.performance.now();
                group.time = timeDifference_1.timeDifference(groupend, groupstart);
                group.reason = "Test suite " + groupName + " passed successfully.";
                reporter.onGroupFinish(group);
            }
            end = perf_hooks_1.performance.now();
            this.time = timeDifference_1.timeDifference(end, start);
            this.pass = passed;
            reporter.onFinish(this);
        };
        /**
         * This method creates a WebAssembly imports object with all the TestContext functions
         * bound to the TestContext.
         *
         * @param {any[]} imports - Every import item specified.
         */
        TestContext.prototype.createImports = function () {
            var _this = this;
            var imports = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                imports[_i] = arguments[_i];
            }
            var result = Object.assign.apply(Object, [{}].concat(imports, [{
                    __aspect: {
                        clearExpected: this.clearExpected.bind(this),
                        debug: this.debug.bind(this),
                        tryCall: this.tryCall.bind(this),
                        logNull: this.logNull.bind(this),
                        logReference: this.logReference.bind(this),
                        logString: this.logString.bind(this),
                        logValue: this.logValue.bind(this),
                        reportDescribe: this.reportDescribe.bind(this),
                        reportEndDescribe: this.reportEndDescribe.bind(this),
                        reportTest: this.reportTest.bind(this),
                        reportBeforeEach: this.reportBeforeEach.bind(this),
                        reportBeforeAll: this.reportBeforeAll.bind(this),
                        reportAfterEach: this.reportAfterEach.bind(this),
                        reportAfterAll: this.reportAfterAll.bind(this),
                        reportTodo: this.reportTodo.bind(this),
                        reportActualNull: this.reportActualNull.bind(this),
                        reportExpectedNull: this.reportExpectedNull.bind(this),
                        reportActualValue: this.reportActualValue.bind(this),
                        reportExpectedValue: this.reportExpectedValue.bind(this),
                        reportActualReference: this.reportActualReference.bind(this),
                        reportExpectedReference: this.reportExpectedReference.bind(this),
                        reportActualString: this.reportActualString.bind(this),
                        reportExpectedString: this.reportExpectedString.bind(this),
                        reportExpectedTruthy: this.reportExpectedTruthy.bind(this),
                        reportExpectedFalsy: this.reportExpectedFalsy.bind(this),
                        reportExpectedFinite: this.reportExpectedFinite.bind(this),
                        reportNegatedTest: this.reportNegatedTest.bind(this),
                    },
                }]));
            result.env = result.env || {};
            var previousAbort = (result.env.abort) || (function () { });
            result.env.abort = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                previousAbort.apply(void 0, args);
                // @ts-ignore
                _this.abort.apply(_this, args);
            };
            return result;
        };
        /**
         * This web assembly linked function creates a test group. It's called when the test suite calls
         * the describe("test", callback) function from within AssemblyScript. It receives a pointer to
         * the description of the tests, forks the top level test group, pushes the suiteName to a list,
         * then pushes the forked group to the top of the test context stack.
         *
         * @param {number} suiteNamePointer
         */
        TestContext.prototype.reportDescribe = function (suiteNamePointer) {
            var group = this.groupStack[this.groupStack.length - 1];
            var nextGroup = group.fork();
            nextGroup.describePointers.push(suiteNamePointer);
            this.groupStack.push(nextGroup);
            this.logTarget = nextGroup;
        };
        /**
         * This web assembly linked function finishes a test group. It's called when the test suite calls
         * the describe("test", callback) function from within AssemblyScript. It pops the current
         * test group from the test context stack and pushes it to the final test group list.
         */
        TestContext.prototype.reportEndDescribe = function () {
            var next = this.groupStack.pop();
            /**
             * If a describe finishes first, it happens BEFORE other describes. This means
             * inner describe blocks run at lower priority than outer describe blocks.
             */
            this.testGroups.unshift(next);
            this.logTarget = this.groupStack[this.groupStack.length - 1];
        };
        /**
         * This web assembly linked function sets the group's "beforeEach" callback pointer to
         * the current groupStackItem.
         *
         * @param {number} callbackPointer - The callback that should run before each test.
         */
        TestContext.prototype.reportBeforeEach = function (callbackPointer) {
            var group = this.groupStack[this.groupStack.length - 1];
            ;
            group.beforeEachPointers.push(callbackPointer);
        };
        /**
         * This web assembly linked function adds the group's "beforeAll" callback pointer to
         * the current groupStackItem.
         *
         * @param {number} callbackPointer - The callback that should run before each test in the
         * current context.
         */
        TestContext.prototype.reportBeforeAll = function (callbackPointer) {
            var group = this.groupStack[this.groupStack.length - 1];
            ;
            group.beforeAllPointers.push(callbackPointer);
        };
        /**
         * This web assembly linked function sets the group's "afterEach" callback pointer.
         *
         * @param {number} callbackPointer - The callback that should run before each test group.
         */
        TestContext.prototype.reportAfterEach = function (callbackPointer) {
            var group = this.groupStack[this.groupStack.length - 1];
            ;
            group.afterEachPointers.push(callbackPointer);
        };
        /**
         * This web assembly linked function adds the group's "afterAll" callback pointer to
         * the current groupStackItem.
         *
         * @param {number} callbackPointer - The callback that should run before each test in the
         * current context.
         */
        TestContext.prototype.reportAfterAll = function (callbackPointer) {
            var group = this.groupStack[this.groupStack.length - 1];
            ;
            group.afterAllPointers.push(callbackPointer);
        };
        /**
         * This is a web assembly utility function that wraps a function call in a try catch block to
         * report success or failure.
         *
         * @param {number} pointer - The function pointer to call. It must accept no parameters and return
         * void.
         * @returns {1 | 0} - If the callback was run successfully without error, it returns 1, else it
         * returns 0.
         */
        TestContext.prototype.tryCall = function (pointer) {
            if (pointer === -1)
                return 1;
            var func = this.wasm.getFunction(pointer);
            try {
                func();
            }
            catch (ex) {
                this.stack = this.getErrorStackTrace(ex);
                return 0;
            }
            return 1;
        };
        /**
         * This adds a logged string to the current test.
         *
         * @param {number} pointer - The pointer to the logged string reference.
         */
        TestContext.prototype.logString = function (pointer) {
            var value = new LogValue_2.LogValue();
            var target = this.logTarget;
            value.message = "\"" + this.wasm.getString(pointer).replace("\"", "\\\"") + "\"";
            value.offset = 0;
            value.pointer = pointer;
            value.stack = this.getLogStackTrace();
            value.target = target;
            // push the log value to the logs
            target.logs.push(value);
        };
        /**
         * Log a reference to the reporter.
         *
         * @param {number} referencePointer - The pointer to the reference.
         * @param {number} offset - The offset of the reference.
         */
        TestContext.prototype.logReference = function (referencePointer, offset) {
            var value = new LogValue_2.LogValue();
            var target = this.logTarget;
            value.bytes = Array.from(this.wasm.U8.slice(referencePointer, referencePointer + offset));
            value.message = "Reference Type";
            value.offset = offset;
            value.pointer = referencePointer;
            value.stack = this.getLogStackTrace();
            value.target = target;
            // push the log value to the logs
            target.logs.push(value);
        };
        /**
         * Log a numevalueric value to the reporter.
         *
         * @param {number} value - The value to be logged.
         */
        TestContext.prototype.logValue = function (numericValue) {
            var value = new LogValue_2.LogValue();
            var target = this.logTarget;
            value.stack = this.getLogStackTrace();
            value.message = "Value " + numericValue.toString();
            value.target = target;
            // push the log value to the logs
            target.logs.push(value);
        };
        /**
         * Log a null value to the reporter.
         */
        TestContext.prototype.logNull = function () {
            // create a new log value
            var value = new LogValue_2.LogValue();
            var target = this.logTarget;
            // collect log metadata
            value.stack = this.getLogStackTrace();
            value.message = "null";
            value.target = target;
            // push the log value to the logs
            target.logs.push(value);
        };
        /**
         * Gets a log stack trace.
         */
        TestContext.prototype.getLogStackTrace = function () {
            try {
                throw new Error("Get stack trace.");
            }
            catch (ex) {
                return ex.stack.toString()
                    .split("\n")
                    .slice(1)
                    .filter(wasmFilter)
                    .join("\n");
            }
        };
        /**
         * Gets an error stack trace.
         */
        TestContext.prototype.getErrorStackTrace = function (ex) {
            var stackItems = ex.stack.toString().split("\n");
            return [stackItems[0]].concat(stackItems.slice(1).filter(wasmFilter)).join("\n");
        };
        /**
         * This is called to stop the debugger.  e.g. `node --inspect-brk asp`.
         */
        TestContext.prototype.debug = function () { debugger; };
        /**
         * This web assembly linked function creates a test from the callback and the testNamePointer in
         * the current group. It assumes that the group has already been created with the describe
         * function. It is called when `it("description", callback)` or `test("description", callback)`
         * is called.
         *
         * @param {number} testNamePointer - The test's name pointer.
         * @param {number} callback - The test's function.
         */
        TestContext.prototype.reportTest = function (testNamePointer, callback) {
            var group = this.groupStack[this.groupStack.length - 1];
            group.testFunctionPointers.push(callback);
            group.testNamePointers.push(testNamePointer);
            group.testMessagePointers.push(-1);
            group.testThrows.push(false);
        };
        /**
         * This web assembly linked function is responsible for reporting tests that are expected
         * to fail. This is useful for verifying that specific application states will throw.
         *
         * @param {number} testNamePointer - The test's name pointer.
         * @param {number} callback - The test's function.
         * @param {number} message - The message associated with this test if it does not throw.
         */
        TestContext.prototype.reportNegatedTest = function (testNamePointer, callback, message) {
            var group = this.groupStack[this.groupStack.length - 1];
            group.testFunctionPointers.push(callback);
            group.testNamePointers.push(testNamePointer);
            group.testMessagePointers.push(message);
            group.testThrows.push(true);
        };
        /**
         * This function reports a single "todo" item in a test suite.
         *
         * @param {number} todoPointer - The todo description string pointer.
         */
        TestContext.prototype.reportTodo = function (todoPointer) {
            var group = this.groupStack[this.groupStack.length - 1];
            group.todos.push(todoPointer);
        };
        /**
          * This function is called after each expectation if the expectation passes. This prevents other
          * unreachable() conditions that throw errors to report actual and expected values too.
          */
        TestContext.prototype.clearExpected = function () {
            this.expected = null;
            this.actual = null;
            this.stack = "";
        };
        /**
         * This function reports an actual null value.
         */
        TestContext.prototype.reportActualNull = function () {
            var value = new ActualValue_1.ActualValue();
            value.message = "null";
            value.stack = this.getLogStackTrace();
            value.target = this.logTarget;
            this.actual = value;
        };
        /**
         * This function reports an expected null value.
         *
         * @param {1 | 0} negated - An indicator if the expectation is negated.
         */
        TestContext.prototype.reportExpectedNull = function (negated) {
            var value = new ActualValue_1.ActualValue();
            value.message = "null";
            value.stack = this.getLogStackTrace();
            value.target = this.logTarget;
            value.negated = negated === 1;
            this.expected = value;
        };
        /**
         * This function reports an actual numeric value.
         *
         * @param {number} numericValue - The value to be expected.
         */
        TestContext.prototype.reportActualValue = function (numericValue) {
            var value = new ActualValue_1.ActualValue();
            value.message = numericValue.toString();
            value.stack = this.getLogStackTrace();
            value.target = this.logTarget;
            this.actual = value;
        };
        /**
         * This function reports an expected numeric value.
         *
         * @param {number} numericValue - The value to be expected
         * @param {1 | 0} negated - An indicator if the expectation is negated.
         */
        TestContext.prototype.reportExpectedValue = function (numericValue, negated) {
            var value = new ActualValue_1.ActualValue();
            value.message = numericValue.toString();
            value.stack = this.getLogStackTrace();
            value.target = this.logTarget;
            value.negated = negated === 1;
            this.expected = value;
        };
        /**
         * This function reports an actual reference value.
         *
         * @param {number} referencePointer - The actual reference pointer.
         * @param {number} offset - The size of the reference in bytes.
         */
        TestContext.prototype.reportActualReference = function (referencePointer, offset) {
            var value = new ActualValue_1.ActualValue();
            value.message = "Reference Type";
            value.stack = this.getLogStackTrace();
            value.target = this.logTarget;
            value.pointer = referencePointer;
            value.offset = offset;
            value.bytes = Array.from(this.wasm.U8.slice(referencePointer, referencePointer + offset));
            this.actual = value;
        };
        /**
         * This function reports an expected reference value.
         *
         * @param {number} referencePointer - The expected reference pointer.
         * @param {number} offset - The size of the reference in bytes.
         * @param {1 | 0} negated - An indicator if the expectation is negated.
         */
        TestContext.prototype.reportExpectedReference = function (referencePointer, offset, negated) {
            var value = new ActualValue_1.ActualValue();
            value.message = "Reference Type";
            value.stack = this.getLogStackTrace();
            value.target = this.logTarget;
            value.pointer = referencePointer;
            value.offset = offset;
            value.bytes = Array.from(this.wasm.U8.slice(referencePointer, referencePointer + offset));
            value.negated = negated === 1;
            this.expected = value;
        };
        /**
         * This function reports an expected truthy value.
         *
         * @param {1 | 0} negated - An indicator if the expectation is negated.
         */
        TestContext.prototype.reportExpectedTruthy = function (negated) {
            var value = new ActualValue_1.ActualValue();
            value.message = "truthy value";
            value.stack = this.getLogStackTrace();
            value.target = this.logTarget;
            value.negated = negated === 1;
            this.expected = value;
        };
        /**
         * This function reports an expected falsy value.
         *
         * @param {1 | 0} negated - An indicator if the expectation is negated.
         */
        TestContext.prototype.reportExpectedFalsy = function (negated) {
            var value = new ActualValue_1.ActualValue();
            value.message = "falsy value";
            value.stack = this.getLogStackTrace();
            value.target = this.logTarget;
            value.negated = negated === 1;
            this.expected = value;
        };
        /**
         * This function reports an expected finite value.
         *
         * @param {1 | 0} negated - An indicator if the expectation is negated.
         */
        TestContext.prototype.reportExpectedFinite = function (negated) {
            var value = new ActualValue_1.ActualValue();
            value.message = "finite value";
            value.stack = this.getLogStackTrace();
            value.target = this.logTarget;
            value.negated = negated === 1;
            this.expected = value;
        };
        /**
         * This function reports an actual string value.
         *
         * @param {number} stringPointer - A pointer that points to the actual string.
         */
        TestContext.prototype.reportActualString = function (stringPointer) {
            var value = new ActualValue_1.ActualValue();
            value.message = "\"" + this.wasm.getString(stringPointer).replace("\"", "\\\"") + "\"";
            value.pointer = stringPointer;
            value.stack = this.getLogStackTrace();
            value.target = this.logTarget;
            this.actual = value;
        };
        /**
         * This function reports an expected string value.
         *
         * @param {number} stringPointer - A pointer that points to the expected string.
         * @param {1 | 0} negated - An indicator if the expectation is negated.
         */
        TestContext.prototype.reportExpectedString = function (stringPointer, negated) {
            var value = new ActualValue_1.ActualValue();
            value.message = "\"" + this.wasm.getString(stringPointer).replace("\"", "\\\"") + "\"";
            value.pointer = stringPointer;
            value.stack = this.getLogStackTrace();
            value.target = this.logTarget;
            value.negated = negated === 1;
            this.expected = value;
        };
        /**
         * This function overrides the provided AssemblyScript `env.abort()` function to catch abort
         * reasons.
         *
         * @param {number} reasonPointer - This points to the message value that causes the expectation to
         * fail.
         * @param {number} _fileNamePointer - The file name that reported the error. (Ignored)
         * @param {number} _line - The line that reported the error. (Ignored)
         * @param {number} _col - The column that reported the error. (Ignored)
         */
        TestContext.prototype.abort = function (reasonPointer, _fileNamePointer, _line, _col) {
            this.message = this.wasm.getString(reasonPointer);
        };
        return TestContext;
    }());
    exports.TestContext = TestContext;
});
define("util/IConfiguration", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("cli", ["require", "exports", "chalk", "path", "glob", "yargs-parser", "assemblyscript/cli/asc", "test/TestContext", "fs", "assemblyscript/lib/loader", "reporter/DefaultTestReporter", "perf_hooks", "util/timeDifference"], function (require, exports, chalk_2, path_1, glob_1, yargs_parser_1, asc_1, TestContext_1, fs_1, loader_1, DefaultTestReporter_2, perf_hooks_2, timeDifference_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    chalk_2 = __importDefault(chalk_2);
    path_1 = __importDefault(path_1);
    glob_1 = __importDefault(glob_1);
    yargs_parser_1 = __importDefault(yargs_parser_1);
    asc_1 = __importDefault(asc_1);
    fs_1 = __importDefault(fs_1);
    var pkg = require("../package.json");
    /**
     * This is the cli entry point and expects an array of arguments from the command line.
     *
     * @param {string[]} args - The arguments from the command line
     */
    function asp(args) {
        // parse the arguments
        var yargs = {
            argv: yargs_parser_1.default(args),
        };
        // Skip ascii art if asked for the version
        if (!(yargs.argv.v || yargs.argv.version)) {
            console.log(chalk_2.default(templateObject_25 || (templateObject_25 = __makeTemplateObject(["{bold.bgWhite.black ", "       ___   _____                       __  \n      /   | / ___/      ____  ___  _____/ /_ \n     / /| | \\__ \\______/ __ \\/ _ \\/ ___/ __/ \n    / ___ |___/ /_____/ /_/ /  __/ /__/ /_   \n   /_/  |_/____/     / .___/\\___/\\___/\\__/   \n                    /_/                      }\n\n  \u26A1AS-pect\u26A1 Test suite runner {bgGreenBright.black [", "]}\n  "], ["{bold.bgWhite.black ",
                "       ___   _____                       __  \n      /   | / ___/      ____  ___  _____/ /_ \n     / /| | \\\\__ \\\\______/ __ \\\\/ _ \\\\/ ___/ __/ \n    / ___ |___/ /_____/ /_/ /  __/ /__/ /_   \n   /_/  |_/____/     / .___/\\\\___/\\\\___/\\\\__/   \n                    /_/                      }\n\n  \u26A1AS-pect\u26A1 Test suite runner {bgGreenBright.black [", "]}\n  "])), "", pkg.version));
        }
        // init script
        if (yargs.argv.i || yargs.argv.init) {
            console.log("");
            console.log(chalk_2.default(templateObject_26 || (templateObject_26 = __makeTemplateObject(["[Log] Initializing test suite files."], ["[Log] Initializing test suite files."]))));
            console.log("");
            // create the assembly folder if it doesn't exist
            var assemblyFolder = path_1.default.join(process.cwd(), "assembly");
            if (!fs_1.default.existsSync(assemblyFolder)) {
                console.log(chalk_2.default(templateObject_27 || (templateObject_27 = __makeTemplateObject(["[Log] Creating folder: ./assembly/"], ["[Log] Creating folder: ./assembly/"]))));
                fs_1.default.mkdirSync(assemblyFolder);
            }
            // Create the test folder if it doesn't exist
            var testFolder = path_1.default.join(process.cwd(), "assembly", "__tests__");
            if (!fs_1.default.existsSync(testFolder)) {
                console.log(chalk_2.default(templateObject_28 || (templateObject_28 = __makeTemplateObject(["[Log] Creating folder: ./assembly/__tests__/"], ["[Log] Creating folder: ./assembly/__tests__/"]))));
                fs_1.default.mkdirSync(testFolder);
                // create the example file only if the __tests__ folder does not exist
                var exampleFile = path_1.default.join(testFolder, "example.spec.ts");
                var exampleFileSource = path_1.default.join(__dirname, "..", "init", "example.spec.ts");
                if (!fs_1.default.existsSync(exampleFile)) {
                    console.log(chalk_2.default(templateObject_29 || (templateObject_29 = __makeTemplateObject(["[Log] Creating file: ./assembly/__tests__/example.spec.ts"], ["[Log] Creating file: ./assembly/__tests__/example.spec.ts"]))));
                    fs_1.default.createReadStream(exampleFileSource, "utf-8")
                        .pipe(fs_1.default.createWriteStream(exampleFile, "utf-8"));
                }
            }
            // create the types file if it doesn't exist for typescript tooling users
            var typesFileSource = path_1.default.join(__dirname, "..", "assembly", "__tests__", "as-pect.d.ts");
            var typesFile = path_1.default.join(testFolder, "as-pect.d.ts");
            if (!fs_1.default.existsSync(typesFile)) {
                console.log(chalk_2.default(templateObject_30 || (templateObject_30 = __makeTemplateObject(["[Log] Creating file: assembly/__tests__/as-pect.d.ts"], ["[Log] Creating file: assembly/__tests__/as-pect.d.ts"]))));
                fs_1.default.createReadStream(typesFileSource, "utf-8")
                    .pipe(fs_1.default.createWriteStream(typesFile, "utf-8"));
            }
            // create the default configuration file
            var configFile = path_1.default.join(process.cwd(), "as-pect.config.js");
            var configFileSource = path_1.default.join(__dirname, "..", "init", "as-pect.config.js");
            if (!fs_1.default.existsSync(configFile)) {
                console.log(chalk_2.default(templateObject_31 || (templateObject_31 = __makeTemplateObject(["[Log] Creating file: as-pect.config.js"], ["[Log] Creating file: as-pect.config.js"]))));
                fs_1.default.createReadStream(configFileSource, "utf-8")
                    .pipe(fs_1.default.createWriteStream(configFile, "utf-8"));
            }
        }
        else if (yargs.argv.v || yargs.argv.version) { // display the version
            console.log(pkg.version);
        }
        else if (yargs.argv.help || yargs.argv.h) { // display the help file
            console.log(chalk_2.default(templateObject_32 || (templateObject_32 = __makeTemplateObject(["\n  {bold.blueBright SYNTAX}\n    {bold.green asp} --config as-pect.config.js\n    {bold.green asp} -c as-pect.config.js\n    {bold.green asp} --init\n    {bold.green asp} -i\n    {bold.green asp} --version\n    {bold.green asp} -v\n\n  {bold.blueBright OPTIONS}\n    {bold.green --version, -v}         Prints the package version and exits.\n    {bold.green --help, -h}            Prints this message and exits.\n    {bold.green --config, -c}          Accepts a configuration file and runs the tests.\n    {bold.green --init, -i}            Creates a test config, an assembly/__tests__ folder and exits.\n  "], ["\n  {bold.blueBright SYNTAX}\n    {bold.green asp} --config as-pect.config.js\n    {bold.green asp} -c as-pect.config.js\n    {bold.green asp} --init\n    {bold.green asp} -i\n    {bold.green asp} --version\n    {bold.green asp} -v\n\n  {bold.blueBright OPTIONS}\n    {bold.green --version, -v}         Prints the package version and exits.\n    {bold.green --help, -h}            Prints this message and exits.\n    {bold.green --config, -c}          Accepts a configuration file and runs the tests.\n    {bold.green --init, -i}            Creates a test config, an assembly/__tests__ folder and exits.\n  "]))));
        }
        else { // run the compiler and test suite
            var start_1 = perf_hooks_2.performance.now();
            // obtain the configuration file
            var configurationPath = path_1.default.resolve(process.cwd(), yargs.argv.c || yargs.argv.config || "./as-pect.config.js");
            console.log(chalk_2.default(templateObject_33 || (templateObject_33 = __makeTemplateObject(["{bgWhite.black [Log]} using configuration ", ""], ["{bgWhite.black [Log]} using configuration ", ""])), configurationPath));
            var configuration_1 = {};
            try {
                configuration_1 = require(configurationPath) || {};
            }
            catch (ex) {
                console.log("");
                console.log(chalk_2.default(templateObject_34 || (templateObject_34 = __makeTemplateObject(["{bgRedBright.black [Error]} There was a problem loading {bold [", "]}."], ["{bgRedBright.black [Error]} There was a problem loading {bold [", "]}."])), configurationPath));
                console.log(ex);
                process.exit(1);
            }
            // configuration must be an object
            if (!configuration_1) {
                console.log(chalk_2.default(templateObject_35 || (templateObject_35 = __makeTemplateObject(["{bgRedBright.black [Error]} configuration at {bold [", "]} is null or not an object."], ["{bgRedBright.black [Error]} configuration at {bold [", "]} is null or not an object."])), configurationPath));
                process.exit(1);
            }
            var include = configuration_1.include || ["assembly/__tests__/**/*.spec.ts"];
            var add = configuration_1.add || ["assembly/__tests__/**/*.include.ts"];
            var flags = configuration_1.flags || {
                "--validate": [],
                "--debug": [],
                "--measure": [],
                "--sourceMap": [],
                /** This is required. Do not change this. */
                "--binaryFile": ["output.wasm"],
            };
            var disclude = configuration_1.disclude || [];
            var reporter_1 = configuration_1.reporter || new DefaultTestReporter_2.DefaultTestReporter();
            // include all the file globs
            console.log("including files " + include.join(", "));
            var testEntryFiles_1 = new Set();
            var addedTestEntryFiles_1 = new Set();
            // for each pattern
            for (var _i = 0, include_1 = include; _i < include_1.length; _i++) {
                var pattern = include_1[_i];
                // push all the resulting files so that each file gets tested individually
                entry: for (var _a = 0, _b = glob_1.default.sync(pattern); _a < _b.length; _a++) {
                    var entry = _b[_a];
                    // test for discludes
                    for (var _c = 0, disclude_1 = disclude; _c < disclude_1.length; _c++) {
                        var test = disclude_1[_c];
                        if (test.test(entry))
                            continue entry;
                    }
                    testEntryFiles_1.add(entry);
                }
            }
            for (var _d = 0, add_1 = add; _d < add_1.length; _d++) {
                var pattern = add_1[_d];
                // push all the added files to the added entry point list
                for (var _e = 0, _f = glob_1.default.sync(pattern); _e < _f.length; _e++) {
                    var entry = _f[_e];
                    addedTestEntryFiles_1.add(entry);
                }
            }
            // loop over each file and create a binary, index it on binaries
            var binaries_1 = {};
            var sourcemaps_1 = {};
            // must include the assembly/index.ts file located in the package
            var entryPath = path_1.default.join(__dirname, "../assembly/index.ts");
            var relativeEntryPath = path_1.default.relative(process.cwd(), entryPath);
            // add the relativeEntryPath of as-pect to the list of compiled files for each test
            addedTestEntryFiles_1.add(relativeEntryPath);
            // Create a test runner, and run each test
            var failed_1 = false;
            var count_1 = testEntryFiles_1.size;
            // create the array of compiler flags from the flags object
            var flagList_1 = Object.entries(flags).reduce(function (args, _a) {
                var flag = _a[0], options = _a[1];
                return args.concat(flag, options);
            }, []);
            var testCount_1 = 0;
            var successCount_1 = 0;
            var groupSuccessCount_1 = 0;
            var groupCount_1 = 0;
            // for each file, synchronously run each test
            Array.from(testEntryFiles_1).forEach(function (file, i) {
                console.log("Compiling: " + file + " " + (i + 1).toString() + " / " + testEntryFiles_1.size.toString());
                asc_1.default.main([file].concat(Array.from(addedTestEntryFiles_1), flagList_1), {
                    stdout: process.stdout,
                    stderr: process.stderr,
                    writeFile: function (name, contents) {
                        var ext = path_1.default.extname(name);
                        // get the wasm file
                        if (ext === ".wasm") {
                            binaries_1[i] = contents;
                            return;
                        }
                        if (ext === ".map") {
                            sourcemaps_1[name] = contents;
                            return;
                        }
                        var outfileName = path_1.default.join(path_1.default.dirname(file), path_1.default.basename(file, path_1.default.extname(file)) + ext);
                        fs_1.default.writeFileSync(outfileName, contents);
                    }
                }, function (error) {
                    // if there are any compilation errors, stop the test suite
                    if (error) {
                        console.log("There was a compilation error when trying to create the wasm binary for file: " + file + ".");
                        console.error(error);
                        return process.exit(1);
                    }
                    // if the binary wasn't emitted, stop the test suite
                    if (!binaries_1[i]) {
                        console.log("There was no output binary file: " + file + ". Did you forget to emit the binary?");
                        return process.exit(1);
                    }
                    var runner = new TestContext_1.TestContext();
                    var imports = runner.createImports(configuration_1.imports || {});
                    var wasm = loader_1.instantiateBuffer(binaries_1[i], imports);
                    // call run buffer because it's already compiled
                    runner.run(wasm, reporter_1, file);
                    count_1 -= 1;
                    failed_1 = failed_1 || !runner.pass;
                    testCount_1 += runner.testGroups.reduce(function (left, right) { return left + right.tests.length; }, 0);
                    successCount_1 += runner.testGroups
                        .reduce(function (left, right) { return left + right.tests.filter(function (e) { return e.pass; }).length; }, 0);
                    groupCount_1 += runner.testGroups.length;
                    groupSuccessCount_1 = runner.testGroups.reduce(function (left, right) { return left + (right.pass ? 1 : 0); }, groupSuccessCount_1);
                    // if any tests failed, and they all ran, exit(1)
                    if (count_1 === 0) {
                        var end = perf_hooks_2.performance.now();
                        var result = failed_1
                            ? chalk_2.default(templateObject_36 || (templateObject_36 = __makeTemplateObject(["{red \u2716 FAIL}"], ["{red \u2716 FAIL}"]))) : chalk_2.default(templateObject_37 || (templateObject_37 = __makeTemplateObject(["{green \u2714 PASS}"], ["{green \u2714 PASS}"])));
                        console.log("~".repeat(process.stdout.columns - 10));
                        console.log("\n  [Result]: " + result + "\n   [Files]: " + testEntryFiles_1.size + " total\n  [Groups]: " + groupCount_1 + " count, " + groupSuccessCount_1 + " pass\n [Summary]: " + successCount_1.toString() + " pass, " + (testCount_1 - successCount_1).toString() + " fail, " + testCount_1.toString() + " total\n    [Time]: " + timeDifference_2.timeDifference(end, start_1).toString() + "ms");
                        if (failed_1) {
                            process.exit(1);
                        }
                    }
                    return 0;
                });
            });
        }
    }
    exports.asp = asp;
    var templateObject_25, templateObject_26, templateObject_27, templateObject_28, templateObject_29, templateObject_30, templateObject_31, templateObject_32, templateObject_33, templateObject_34, templateObject_35, templateObject_36, templateObject_37;
});
define("as-pect", ["require", "exports", "test/TestContext", "test/TestGroup", "test/TestReporter", "test/TestResult", "reporter/DefaultTestReporter", "util/ActualValue", "util/LogValue", "cli"], function (require, exports, TestContext_2, TestGroup_2, TestReporter_2, TestResult_2, DefaultTestReporter_3, ActualValue_2, LogValue_3, cli_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(TestContext_2);
    __export(TestGroup_2);
    __export(TestReporter_2);
    __export(TestResult_2);
    __export(DefaultTestReporter_3);
    __export(ActualValue_2);
    __export(LogValue_3);
    __export(cli_1);
});
define("test", ["require", "exports", "cli"], function (require, exports, cli_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    cli_2.asp(process.argv.slice(2));
});
//# sourceMappingURL=as-pect.amd.js.map